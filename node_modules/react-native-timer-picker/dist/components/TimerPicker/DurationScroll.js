"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-var-requires */
var react_1 = __importStar(require("react"));
var react_native_1 = require("react-native");
var generateNumbers_1 = require("../../utils/generateNumbers");
var colorToRgba_1 = require("../../utils/colorToRgba");
var getAdjustedLimit_1 = require("../../utils/getAdjustedLimit");
var getScrollIndex_1 = require("../../utils/getScrollIndex");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var KEY_EXTRACTOR = function (_, index) { return index.toString(); };
var DurationScroll = (0, react_1.forwardRef)(function (_a, ref) {
    var _b, _c, _d, _e;
    var numberOfItems = _a.numberOfItems, label = _a.label, _f = _a.initialValue, initialValue = _f === void 0 ? 0 : _f, onDurationChange = _a.onDurationChange, _g = _a.padNumbersWithZero, padNumbersWithZero = _g === void 0 ? false : _g, _h = _a.disableInfiniteScroll, disableInfiniteScroll = _h === void 0 ? false : _h, limit = _a.limit, padWithNItems = _a.padWithNItems, pickerGradientOverlayProps = _a.pickerGradientOverlayProps, LinearGradient = _a.LinearGradient, testID = _a.testID, styles = _a.styles;
    var flatListRef = (0, react_1.useRef)(null);
    var data = (0, generateNumbers_1.generateNumbers)(numberOfItems, {
        padWithZero: padNumbersWithZero,
        repeatNTimes: 3,
        disableInfiniteScroll: disableInfiniteScroll,
        padWithNItems: padWithNItems,
    });
    var numberOfItemsToShow = 1 + padWithNItems * 2;
    var adjustedLimited = (0, getAdjustedLimit_1.getAdjustedLimit)(limit, numberOfItems);
    var initialScrollIndex = (0, getScrollIndex_1.getScrollIndex)({
        value: initialValue,
        numberOfItems: numberOfItems,
        padWithNItems: padWithNItems,
        disableInfiniteScroll: disableInfiniteScroll,
    });
    (0, react_1.useImperativeHandle)(ref, function () { return ({
        reset: function (options) {
            var _a, _b;
            (_a = flatListRef.current) === null || _a === void 0 ? void 0 : _a.scrollToIndex({
                animated: (_b = options === null || options === void 0 ? void 0 : options.animated) !== null && _b !== void 0 ? _b : false,
                index: initialScrollIndex,
            });
        },
        setValue: function (value, options) {
            var _a, _b;
            (_a = flatListRef.current) === null || _a === void 0 ? void 0 : _a.scrollToIndex({
                animated: (_b = options === null || options === void 0 ? void 0 : options.animated) !== null && _b !== void 0 ? _b : false,
                index: (0, getScrollIndex_1.getScrollIndex)({
                    value: value,
                    numberOfItems: numberOfItems,
                    padWithNItems: padWithNItems,
                    disableInfiniteScroll: disableInfiniteScroll,
                }),
            });
        },
    }); });
    var renderItem = (0, react_1.useCallback)(function (_a) {
        var item = _a.item;
        var intItem = parseInt(item);
        return (<react_native_1.View key={item} style={styles.pickerItemContainer} testID="picker-item">
                        <react_native_1.Text style={[
                styles.pickerItem,
                intItem > adjustedLimited.max ||
                    intItem < adjustedLimited.min
                    ? styles.disabledPickerItem
                    : {},
            ]}>
                            {item}
                        </react_native_1.Text>
                    </react_native_1.View>);
    }, [
        adjustedLimited.max,
        adjustedLimited.min,
        styles.disabledPickerItem,
        styles.pickerItem,
        styles.pickerItemContainer,
    ]);
    var onMomentumScrollEnd = (0, react_1.useCallback)(function (e) {
        var _a, _b;
        var newIndex = Math.round(e.nativeEvent.contentOffset.y /
            styles.pickerItemContainer.height);
        var newDuration = (disableInfiniteScroll
            ? newIndex
            : newIndex + padWithNItems) %
            (numberOfItems + 1);
        // check limits
        if (newDuration > adjustedLimited.max) {
            var targetScrollIndex = newIndex - (newDuration - adjustedLimited.max);
            (_a = flatListRef.current) === null || _a === void 0 ? void 0 : _a.scrollToIndex({
                animated: true,
                index: 
                // guard against scrolling beyond end of list
                targetScrollIndex >= 0
                    ? targetScrollIndex
                    : adjustedLimited.max - 1,
            }); // scroll down to max
            newDuration = adjustedLimited.max;
        }
        else if (newDuration < adjustedLimited.min) {
            var targetScrollIndex = newIndex + (adjustedLimited.min - newDuration);
            (_b = flatListRef.current) === null || _b === void 0 ? void 0 : _b.scrollToIndex({
                animated: true,
                index: 
                // guard against scrolling beyond end of list
                targetScrollIndex <= data.length - 1
                    ? targetScrollIndex
                    : adjustedLimited.min,
            }); // scroll up to min
            newDuration = adjustedLimited.min;
        }
        onDurationChange(newDuration);
    }, [
        adjustedLimited.max,
        adjustedLimited.min,
        data.length,
        disableInfiniteScroll,
        numberOfItems,
        onDurationChange,
        padWithNItems,
        styles.pickerItemContainer.height,
    ]);
    var onViewableItemsChanged = (0, react_1.useCallback)(function (_a) {
        var _b, _c, _d, _e;
        var viewableItems = _a.viewableItems;
        if (((_b = viewableItems[0]) === null || _b === void 0 ? void 0 : _b.index) &&
            viewableItems[0].index < numberOfItems * 0.5) {
            (_c = flatListRef.current) === null || _c === void 0 ? void 0 : _c.scrollToIndex({
                animated: false,
                index: viewableItems[0].index + numberOfItems,
            });
        }
        else if (((_d = viewableItems[0]) === null || _d === void 0 ? void 0 : _d.index) &&
            viewableItems[0].index >= numberOfItems * 2.5) {
            (_e = flatListRef.current) === null || _e === void 0 ? void 0 : _e.scrollToIndex({
                animated: false,
                index: viewableItems[0].index - numberOfItems,
            });
        }
    }, [numberOfItems]);
    var getItemLayout = (0, react_1.useCallback)(function (_, index) { return ({
        length: styles.pickerItemContainer.height,
        offset: styles.pickerItemContainer.height * index,
        index: index,
    }); }, [styles.pickerItemContainer.height]);
    var viewabilityConfigCallbackPairs = (0, react_1.useRef)([
        {
            viewabilityConfig: { viewAreaCoveragePercentThreshold: 25 },
            onViewableItemsChanged: onViewableItemsChanged,
        },
    ]);
    return (<react_native_1.View testID={testID} style={{
            height: styles.pickerItemContainer.height * numberOfItemsToShow,
            overflow: "hidden",
        }}>
                <react_native_1.FlatList ref={flatListRef} data={data} getItemLayout={getItemLayout} initialScrollIndex={initialScrollIndex} windowSize={numberOfItemsToShow} renderItem={renderItem} keyExtractor={KEY_EXTRACTOR} showsVerticalScrollIndicator={false} decelerationRate="fast" scrollEventThrottle={16} snapToAlignment="start" 
    // used in place of snapToOffset due to bug on Android
    snapToOffsets={__spreadArray([], Array(data.length), true).map(function (_, i) { return i * styles.pickerItemContainer.height; })} viewabilityConfigCallbackPairs={!disableInfiniteScroll
            ? viewabilityConfigCallbackPairs === null || viewabilityConfigCallbackPairs === void 0 ? void 0 : viewabilityConfigCallbackPairs.current
            : undefined} onMomentumScrollEnd={onMomentumScrollEnd} testID="duration-scroll-flatlist"/>
                <react_native_1.View style={styles.pickerLabelContainer}>
                    {typeof label === "string" ? (<react_native_1.Text style={styles.pickerLabel}>{label}</react_native_1.Text>) : (label !== null && label !== void 0 ? label : null)}
                </react_native_1.View>
                {LinearGradient ? (<>
                        <LinearGradient colors={[
                (_b = styles.pickerContainer.backgroundColor) !== null && _b !== void 0 ? _b : "white",
                (0, colorToRgba_1.colorToRgba)({
                    color: (_c = styles.pickerContainer
                        .backgroundColor) !== null && _c !== void 0 ? _c : "white",
                    opacity: 0,
                }),
            ]} start={{ x: 1, y: 0.3 }} end={{ x: 1, y: 1 }} {...pickerGradientOverlayProps} style={[styles.pickerGradientOverlay, { top: 0 }]}/>
                        <LinearGradient colors={[
                (0, colorToRgba_1.colorToRgba)({
                    color: (_d = styles.pickerContainer
                        .backgroundColor) !== null && _d !== void 0 ? _d : "white",
                    opacity: 0,
                }),
                (_e = styles.pickerContainer.backgroundColor) !== null && _e !== void 0 ? _e : "white",
            ]} start={{ x: 1, y: 0 }} end={{ x: 1, y: 0.7 }} {...pickerGradientOverlayProps} style={[
                styles.pickerGradientOverlay,
                { bottom: -1 },
            ]}/>
                    </>) : null}
            </react_native_1.View>);
});
exports.default = react_1.default.memo(DurationScroll);
