"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.colorToRgba = void 0;
var colorToRgba = function (variables) {
    // this function is required for expo-linear-gradient on iOS. To fade to transparent, we need
    // to be able to add opacity to the background color. Supplying 'transparent' does not work
    // because that is actually a transparent black (rgba(0, 0, 0, 1)), which results in dodgy rendering
    var color = variables.color, _a = variables.opacity, opacity = _a === void 0 ? 1 : _a;
    // Handle named colors
    var namedColors = {
        transparent: "rgba(0, 0, 0, 0)",
        black: "rgba(0, 0, 0, 1)",
        white: "rgba(255, 255, 255, 1)",
        blue: "rgba(0, 0, 255, 1)",
        green: "rgba(0, 128, 0, 1)",
        gray: "rgba(128, 128, 128, 1)",
        red: "rgba(255, 0, 0, 1)",
    };
    if (color in namedColors) {
        return namedColors[color];
    }
    // Handle RGB format
    if (color.startsWith("rgb(")) {
        var rgbValues = color
            .replace("rgb(", "")
            .replace(")", "")
            .split(",")
            .map(function (value) { return parseInt(value.trim(), 10); });
        var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];
        return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(opacity, ")");
    }
    // Handle hex format
    if (color.startsWith("#")) {
        var hexColor = color.slice(1);
        if (hexColor.length === 3) {
            hexColor = hexColor
                .split("")
                .map(function (value) { return value + value; })
                .join("");
        }
        var r = parseInt(hexColor.slice(0, 2), 16);
        var g = parseInt(hexColor.slice(2, 4), 16);
        var b = parseInt(hexColor.slice(4, 6), 16);
        return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(opacity, ")");
    }
    return color; // Return unchanged if unable to parse
};
exports.colorToRgba = colorToRgba;
